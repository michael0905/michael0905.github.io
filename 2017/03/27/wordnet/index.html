<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>WordNet | Yiyuan Liu&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近在coursera上学习Princeton大学的Algorithm PartII，这个系列的两门课是我见过最好的算法课。主讲Robert Sedgewick师承高德纳，声名远播，虽然年纪大了，但是讲课思路清晰，深入浅出。与Kevin Wayne共同编著的《算法》第四版作为教材，没有《算法导论》那么偏理论、晦涩难懂，能够把常见的数据结构和算法讲得很透彻，容易理解。更值得称道的是这门课编程作业及其">
<meta property="og:type" content="article">
<meta property="og:title" content="WordNet">
<meta property="og:url" content="http://yoursite.com/2017/03/27/wordnet/index.html">
<meta property="og:site_name" content="Yiyuan Liu's Blog">
<meta property="og:description" content="最近在coursera上学习Princeton大学的Algorithm PartII，这个系列的两门课是我见过最好的算法课。主讲Robert Sedgewick师承高德纳，声名远播，虽然年纪大了，但是讲课思路清晰，深入浅出。与Kevin Wayne共同编著的《算法》第四版作为教材，没有《算法导论》那么偏理论、晦涩难懂，能够把常见的数据结构和算法讲得很透彻，容易理解。更值得称道的是这门课编程作业及其">
<meta property="og:updated_time" content="2017-03-28T07:58:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="WordNet">
<meta name="twitter:description" content="最近在coursera上学习Princeton大学的Algorithm PartII，这个系列的两门课是我见过最好的算法课。主讲Robert Sedgewick师承高德纳，声名远播，虽然年纪大了，但是讲课思路清晰，深入浅出。与Kevin Wayne共同编著的《算法》第四版作为教材，没有《算法导论》那么偏理论、晦涩难懂，能够把常见的数据结构和算法讲得很透彻，容易理解。更值得称道的是这门课编程作业及其">
  
    <link rel="alternate" href="/atom.xml" title="Yiyuan Liu&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Yiyuan Liu&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-wordnet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/27/wordnet/" class="article-date">
  <time datetime="2017-03-27T03:25:16.000Z" itemprop="datePublished">2017-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      WordNet
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在coursera上学习Princeton大学的Algorithm PartII，这个系列的两门课是我见过最好的算法课。主讲Robert Sedgewick师承高德纳，声名远播，虽然年纪大了，但是讲课思路清晰，深入浅出。与Kevin Wayne共同编著的《算法》第四版作为教材，没有《算法导论》那么偏理论、晦涩难懂，能够把常见的数据结构和算法讲得很透彻，容易理解。<br>更值得称道的是这门课编程作业及其评分系统。上课的内容是基础的数据结构和算法，但编程作业往往是这些算法的实际应用，能真正理解为什么在给定的情况下要使用这样的数据结构、算法。作业的评分不仅仅是看正确与否，还有运行时间、内存的要求，会给出详细的分析报告，如果不是ACM大神，这些作业都值得花时间去仔细琢磨。<br>下面进入正题，第一周的作业WordNet</p>
<p>##题目<br>WordNet is a semantic lexicon for theEnglish language that is used extensively by computational linguistsand cognitive scientists; for example, it was a key component in IBM’sWatson.WordNet groups words into sets of synonyms called synsets and describes semantic relationships between them.One such relationship is the is-a relationship, which connects a hyponym(more specific synset) to a hypernym (more general synset).For example, locomotion is a hypernym of runningand running is a hypernym of dash.</p>
<p>The WordNet digraph.Your first task is to build the wordnet digraph: each vertex v is an integer that represents a synset, and each directed edge v→w represents that w is a hypernym of v.The wordnet digraph is a rooted DAG: it is acylic and has one vertex thatis an ancestor of every other vertex.However, it is not necessarily a tree because a synset can have more than onehypernym. A small subgraph of the wordnet digraph is illustrated below.</p>
<p>The WordNet input file formats.We now describe the two data files that you will use to create the wordnet digraph.The files are in CSV format: each line contains a sequence of fields,separated by commas.</p>
<p>List of noun synsets.The file synsets.txtlists all the (noun) synsets in WordNet.The first field is the synset id (an integer),the second field is the synonym set (or synset), and thethird field is its dictionary definition (or gloss).For example, the line<br>36,AND_circuit AND_gate,a circuit in a computer that fires only when all of its inputs fire<br>means that the synset { AND_circuit, AND_gate }has an id number of 36 and it’s gloss isa circuit in a computer that fires only when all of its inputs fire.The individual nouns that comprise a synset are separatedby spaces (and a synset element is not permitted to contain a space).The S synset ids are numbered 0 through S − 1;the id numbers will appear consecutively in the synset file.<br>List of hypernyms.The file hypernyms.txtcontains the hypernym relationships:The first field is a synset id; subsequent fields are the id numbersof the synset’s hypernyms. For example, the following line<br>164,21012,56099<br>means that the the synset 164 (“Actifed”) has two hypernyms:21012 (“antihistamine”) and56099 (“nasal_decongestant”),representing that Actifed is both an antihistamine and a nasal decongestant.The synsets are obtained from the corresponding lines in the file synsets.txt.</p>
<p>164,Actifed,trade name for a drug containing an antihistamine and a decongestant…<br>21012,antihistamine,a medicine used to treat allergies…<br>56099,nasal_decongestant,a decongestant that provides temporary relief of nasal…<br>WordNet data type.Implement an immutable data type WordNet with the following API:</p>
<p>// constructor takes the name of the two input files<br>public WordNet(String synsets, String hypernyms)</p>
<p>// the set of nouns (no duplicates), returned as an Iterable<br>public Iterable<string> nouns()</string></p>
<p>// is the word a WordNet noun?<br>public boolean isNoun(String word)</p>
<p>// distance between nounA and nounB (defined below)<br>public int distance(String nounA, String nounB)</p>
<p>// a synset (second field of synsets.txt) that is the common ancestor of nounA and nounB<br>// in a shortest ancestral path (defined below)<br>public String sap(String nounA, String nounB)</p>
<p>// for unit testing of this class<br>public static void main(String[] args)<br>The constructor should throw a java.lang.IllegalArgumentExceptionif the input does not correspond to a rooted DAG.The distance() and sap() methodsshould throw a java.lang.IllegalArgumentExceptionunless both of the noun arguments are WordNet nouns.<br>Your data type should use space linear in the input size(size of synsets and hypernyms files).The constructor should take time linearithmic (or better) in the input size.The method isNoun() should run in time logarithmic (or better) inthe number of nouns.The methods distance() and sap() should run in time linear in thesize of the WordNet digraph.</p>
<p>Shortest ancestral path.An ancestral path between two verticesv and w in a digraph is a directed path fromv to a common ancestor x, together witha directed path from w to the same ancestor x. A shortest ancestral path is an ancestral path of minimum total length.For example, in the digraph at left(digraph1.txt),the shortest ancestral path between3 and 11 has length 4 (with common ancestor 1).In the digraph at right (digraph2.txt),one ancestral path between 1 and 5 has length 4(with common ancestor 5), but the shortest ancestral path has length 2(with common ancestor 0).</p>
<p>SAP data type.Implement an immutable data type SAP with the following API:</p>
<p>// constructor takes a digraph (not necessarily a DAG)<br>public SAP(Digraph G)</p>
<p>// length of shortest ancestral path between v and w; -1 if no such path<br>public int length(int v, int w)</p>
<p>// a common ancestor of v and w that participates in a shortest ancestral path; -1 if no such path<br>public int ancestor(int v, int w)</p>
<p>// length of shortest ancestral path between any vertex in v and any vertex in w; -1 if no such path<br>public int length(Iterable<integer> v, Iterable<integer> w)</integer></integer></p>
<p>// a common ancestor that participates in shortest ancestral path; -1 if no such path<br>public int ancestor(Iterable<integer> v, Iterable<integer> w)</integer></integer></p>
<p>// for unit testing of this class (such as the one below)<br>public static void main(String[] args)<br>All methods should throw a java.lang.IndexOutOfBoundsException if one (or more) of the input arguments is not between 0 and G.V() - 1.You may assume that the iterable arguments contain at least one integer.All methods (and the constructor) should take time at mostproportional to E + Vin the worst case, where E and V are the number of edges and verticesin the digraph, respectively.Your data type should use space proportional to E + V.<br>Test client.The following test client takes the name of a digraph input file asas a command-line argument, constructs the digraph,reads in vertex pairs from standard input,and prints out the length of the shortest ancestral path between the two verticesand a common ancestor that participates in that path:</p>
<p>public static void main(String[] args) {<br>    In in = new In(args[0]);<br>    Digraph G = new Digraph(in);<br>    SAP sap = new SAP(G);<br>    while (!StdIn.isEmpty()) {<br>        int v = StdIn.readInt();<br>        int w = StdIn.readInt();<br>        int length   = sap.length(v, w);<br>        int ancestor = sap.ancestor(v, w);<br>        StdOut.printf(“length = %d, ancestor = %d\n”, length, ancestor);<br>    }<br>}<br>Here is a sample execution:<br>% more digraph1.txt             % java SAP digraph1.txt<br>13                              3 11<br>11                              length = 4, ancestor = 1<br> 7  3<br> 8  3                           9 12<br> 3  1                           length = 3, ancestor = 5<br> 4  1<br> 5  1                           7 2<br> 9  5                           length = 4, ancestor = 0<br>10  5<br>11 10                           1 6<br>12 10                           length = -1, ancestor = -1<br> 1  0<br> 2  0<br>Measuring the semantic relatedness of two nouns.Semantic relatedness refers to the degree to which two concepts are related. Measuring semantic relatedness is a challenging problem. For example, most of us agree that George Bush and John Kennedy (two U.S. presidents)are more related than are George Bushand chimpanzee (two primates). However, not most of us agree that George Bush and Eric Arthur Blair are related concepts. But if one is aware that George Bush and Eric Arthur Blair (aka George Orwell) are both communicators, then it becomes clear that the two concepts might be related.</p>
<p>We define the semantic relatednessof two wordnet nouns A and B as follows:</p>
<p>distance(A, B) = distance is the minimum length of any ancestral path betweenany synset v of A and any synset w of B.<br>This is the notion of distance that you will use to implement thedistance() and sap() methods in the WordNet data type.</p>
<p>Outcast detection.Given a list of wordnet nouns A1, A2,…, An, which nounis the least related to the others? To identify an outcast,compute the sum of the distances between each noun and every other one:</p>
<p>di   =  dist(Ai, A1)   +  dist(Ai, A2)   +   …   +   dist(Ai, An)<br>and return a noun Atfor which dt is maximum.<br>Implement an immutable data type Outcast with the following API:</p>
<p>// constructor takes a WordNet object<br>public Outcast(WordNet wordnet)</p>
<p>// given an array of WordNet nouns, return an outcast<br>public String outcast(String[] nouns)</p>
<p>// for unit testing of this class (such as the one below)<br>public static void main(String[] args)<br>Assume that argument array to the outcast() methodcontains only valid wordnet nouns (and that it contains at least two such nouns).<br>The following test client takes from the command line the name of a synset file, the name of a hypernym file, followed by thenames of outcast files, and prints out an outcast in each file:</p>
<p>public static void main(String[] args) {<br>    WordNet wordnet = new WordNet(args[0], args[1]);<br>    Outcast outcast = new Outcast(wordnet);<br>    for (int t = 2; t &lt; args.length; t++) {<br>        In in = new In(args[t]);<br>        String[] nouns = in.readAllStrings();<br>        StdOut.println(args[t] + “: “ + outcast.outcast(nouns));<br>    }<br>}<br>Here is a sample execution:<br>% more outcast5.txt<br>horse zebra cat bear table</p>
<p>% more outcast8.txt<br>water soda bed orange_juice milk apple_juice tea coffee</p>
<p>% more outcast11.txt<br>apple pear peach banana lime lemon blueberry strawberry mango watermelon potato</p>
<p>% java Outcast synsets.txt hypernyms.txt outcast5.txt outcast8.txt outcast11.txt<br>outcast5.txt: table<br>outcast8.txt: bed<br>outcast11.txt: potato</p>
<p>##题目分析<br>wordnet是一个有上下位关系的英语词典，可以描述词语间的关系。下位词是上位词的一种具体描述，是一种isa关系。例如running是dash的上位词。从数据结构上来看wordnet是一个有向无环图。每个节点是一个同义词集合（synset），一个英语单词或复合词可能有多个意思，因此可能会出现在多个不同节点中。每条边都是由下位词指向上位词，有且仅有从下位词到上位词的路径，因此不可能存在环。<br>题目中wordnet是以synsets.txt和hypernyms.txt的形式给出。synsets.txt中按字母顺序给出了所有同义词集合的序号、集合、描述。hypernyms.txt按同义词集合的序号给出了上下位的关系，每行第一个序号是下位词，之后的序号都是上位词。一个下位词可能存在多个上位词。<br>题目的要求是实现三个类：</p>
<ul>
<li>WordNet.java</li>
<li>SAP.java</li>
<li>Outcast.java</li>
</ul>
<p>SAP.java是一个基础类，给定一个有向图，计算两点之间的最短距离，以及两点的共同祖先。首先应该完成这个类。<br>WordNet.java中实现计算wordnet结构中两个词的最短距离及共同祖先。<br>Outcast.java就比较简单了，找出一组词中最不相关的一个，调用WordNet.java很容易实现。</p>
<p>##SAP.java<br>下面具体分析每个类的实现<br>首先实现SAP.java，在这个类中实现计算最短距离和共同祖先的算法，然后可以应用到wordnet中。</p>
<p>###分析<br>求最短路径和共同祖先的思想就是从两个不同节点出发，找到都能到达且距离最短的节点。要计算距离，使用广度优先搜索，并且保存和更新每个节点的到出发点的距离。</p>
<p>成员变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private Digraph digraph;</div><div class="line"></div><div class="line">private int ancestor;</div><div class="line">    </div><div class="line">private int length;</div></pre></td></tr></table></figure>
<p>构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public SAP(Digraph G) &#123;</div><div class="line">       if (G == null) throw new NullPointerException();</div><div class="line">       this.digraph = G;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>由于最短距离是两个节点到某公共节点的距离组合，可能出现多种情况，因此自定义一个数据结构Node来表示公共节点，把所有可能的公共节点放入一个优先队列中，最后从中取最小值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private class Node implements Comparable&lt;Node&gt; &#123;</div><div class="line">        private int length;</div><div class="line">        private int id;</div><div class="line"></div><div class="line">        Node(int length, int id) &#123;</div><div class="line">            this.length = length;</div><div class="line">            this.id = id;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public int compareTo(Node o) &#123;</div><div class="line">            if (length &gt; o.length) &#123;</div><div class="line">                return 1;</div><div class="line">            &#125; else if (length == o.length) &#123;</div><div class="line">                return 0;</div><div class="line">            &#125; else &#123;</div><div class="line">                return -1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">```   </div><div class="line">求最短距离的完整代码：</div><div class="line"></div><div class="line">1. 先对一个节点进行广度优先搜素，计算到所有节点的距离。</div><div class="line">2. 对另一个节点进行广度优先搜素，计算到所有节点的距离，如果某节点可以从两个节点分别到达，则存在优先队列中。</div><div class="line">3. 从优先队列中取出最小值，即为最短距离。</div></pre></td></tr></table></figure>
<p>// length of shortest ancestral path between v and w; -1 if no such path<br>    public int length(int v, int w) {<br>        if (v &lt; 0 || v &gt;= digraph.V() || w &lt; 0 || w &gt;= digraph.V())<br>            throw new IndexOutOfBoundsException();<br>        MinPQ<node> possibleLength = new MinPQ();<br>        boolean[] marked = new boolean[this.digraph.V()];<br>        marked[v] = true;<br>        int[] pathV = new int[digraph.V()];<br>        int[] pathW = new int[digraph.V()];<br>        for (int i = 0; i &lt; digraph.V(); i++) {<br>            pathV[i] = -1;<br>            pathW[i] = -1;<br>        }<br>        pathV[v] = 0;<br>        pathW[w] = 0;</node></p>
<pre><code>    // bfs on v
    Queue&lt;Integer&gt; queue = new Queue&lt;&gt;();
    queue.enqueue(v);
    while (!queue.isEmpty()) {
        int vertex = queue.dequeue();
        for (int nextVertex : digraph.adj(vertex)) {
            if (!marked[nextVertex]) {
                marked[nextVertex] = true;
                queue.enqueue(nextVertex);
                if (pathV[nextVertex] == -1 || pathV[nextVertex] &gt; pathV[vertex] + 1) {
                    pathV[nextVertex] = pathV[vertex] + 1;
                }

            }
        }
    }

    // bfs on w
    marked = new boolean[this.digraph.V()];
    marked[w] = true;
    queue.enqueue(w);
    while (!queue.isEmpty()) {
        int vertex = queue.dequeue();
        if (pathV[vertex] &gt; -1) {
            Node node = new Node(pathV[vertex] + pathW[vertex], vertex);
            possibleLength.insert(node);
        }
        for (int nextVertex : digraph.adj(vertex)) {
            if (!marked[nextVertex]) {
                marked[nextVertex] = true;
                queue.enqueue(nextVertex);
                if (pathW[nextVertex] == -1 || pathW[nextVertex] &gt; pathW[vertex] + 1) {
                    pathW[nextVertex] = pathW[vertex] + 1;
                }

            }
        }
    }
    if (possibleLength.size() &gt; 0) {
        Node node = possibleLength.delMin();
        this.length = node.length;
        this.ancestor = node.id;
    } else {
        this.length = -1;
        this.ancestor = -1;
    }
    return this.length;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">共同祖先在计算最短距离时也能获得，Node中的id就是共同祖先，因此可以复用。</div></pre></td></tr></table></figure>
<p>// a common ancestor of v and w that participates in a shortest ancestral path; -1 if no such path<br>    public int ancestor(int v, int w) {<br>        length(v, w);<br>        return this.ancestor;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">输入的v,w为多个节点时，直接用暴力for循环找出每两个节点间的最短距离和共同祖先，存到优先队列中，最后取出的就是两组节点间的最短纪录和共同祖先。</div><div class="line">代码：</div></pre></td></tr></table></figure></p>
<pre><code>// length of shortest ancestral path between any vertex in v and any vertex in w; -1 if no such path
public int length(Iterable&lt;Integer&gt; v, Iterable&lt;Integer&gt; w) {
    if (v == null || w == null) throw new NullPointerException();
    MinPQ&lt;Node&gt; possibleNodes = new MinPQ();
    for (int nodeV : v) {
        if (nodeV &lt; 0 || nodeV &gt; this.digraph.V())
            throw new IndexOutOfBoundsException();
        for (int nodeW : w) {
            if (nodeW &lt; 0 || nodeW &gt; this.digraph.V())
                throw new IndexOutOfBoundsException();

            Node node = new Node(length(nodeV, nodeW), ancestor(nodeV, nodeW));
            possibleNodes.insert(node);
        }
    }

    if (possibleNodes.size() &gt; 0) {
        Node node = possibleNodes.delMin();
        this.length = node.length;
        this.ancestor = node.id;
    } else {
        this.length = -1;
        this.ancestor = -1;
    }
    return this.length;
}

// a common ancestor that participates in shortest ancestral path; -1 if no such path
public int ancestor(Iterable&lt;Integer&gt; v, Iterable&lt;Integer&gt; w) {
    length(v, w);
    return this.ancestor;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## WordNet.java</div><div class="line">要把sap中的算法实际高效地应用到wordnet中并不简单，需要找到适合的数据结构来储存我们需要的信息并且能够高效地查询。</div><div class="line"></div><div class="line">题目要求</div><div class="line"></div><div class="line">1. 返回wordnet中所有的词</div><div class="line">2. 判断一个词是否在wordnet中</div><div class="line">3. 两个词的最短距离</div><div class="line">4. 两个词最短路径上的共同上位词的同义词集合</div><div class="line"></div><div class="line"></div><div class="line">要做到1和2两个要求，需要一个没有重复词的集合，而且能够根据词来快速搜索。提到快速搜索，立即想到时间复杂度log(n)的二叉搜索树，正好符合题目的时间要求。因此，使用PartI中讲到过的SET&lt;key&gt;(在Alg4.jar中，用平衡二叉树实现log(n)的插入、搜索)。</div><div class="line"></div><div class="line">SET需要一个key来实现搜索。要求搜索的是词，但不能直接以string作为key，因为还要考虑到最短路径的实现。因此，用一个自定义结构：实现Comparable接口时比较的是词的字母顺序，另外由于词的多义性用一个ArrayList存放出现在wordnet中的可能位置。</div></pre></td></tr></table></figure>
<p>private class Node implements Comparable<node> {<br>        private ArrayList<integer> ids;<br>        private String noun;<br>        Node(String noun) {<br>            this.noun = noun;<br>            this.ids = new ArrayList&lt;&gt;();<br>        }</integer></node></p>
<pre><code>    private void addId(int id) {
        this.ids.add(id);
    }

    private ArrayList&lt;Integer&gt; getIds() {
        return this.ids;
    }

    @Override
    public int compareTo(Node o) {
        return this.noun.compareTo(o.noun);
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">成员变量：</div></pre></td></tr></table></figure>
<p>private SAP wordnetSap;<br>    private Digraph digraph;<br>    private boolean hasCycle;<br>    private boolean[] onStack;<br>    private boolean[] marked;<br>    private ArrayList<integer> possibleRoots; // a DAG has only one root<br>    private ArrayList<string[]> synsets; // synsets for each wordnet node<br>    private SET<node> allNouns; // SET to store Node<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">构造方法：读取synsets.txt和hypernyms.txt,构建表示wordnet的图。Node表示词以及词可能出现的位置，建立SET。与sap中不同，共同祖先需要根据序号返回同义词组，与SET的思路不一致，因此还需要一个ArrayList来表示每个序号对应的同义词组。</div><div class="line"></div><div class="line">根据题目要求，还需要检查构建的wordnet图是否合法，即检查是否无环、是否只有一个root。这个检查合法性同样用广度优先搜索可以完成：</div><div class="line"></div><div class="line">* 是否无环：搜索时如果之前访问过某节点，则构成环。</div><div class="line">* 是否只有一个root：无论从哪个节点开始搜索，最后一个节点（没有指向其他节点的边）是唯一的。</div></pre></td></tr></table></figure></node></string[]></integer></p>
<p>public WordNet(String synsets, String hypernyms) {<br>        if (synsets == null || hypernyms == null)<br>            throw new NullPointerException();<br>        possibleRoots = new ArrayList&lt;&gt;();<br>        this.synsets = new ArrayList&lt;&gt;();<br>        allNouns = new SET<node>();<br>        int count = 0;<br>        try {<br>            BufferedReader in = new BufferedReader(new FileReader(synsets));<br>            String line;<br>            while ((line = in.readLine()) != null) {<br>                String[] parts = line.split(“,”);<br>                String aSynset = parts[1];<br>                String[] strings = aSynset.split(“ “);<br>                for (String str : strings) {<br>                    Node node = new Node(str);<br>                    if (this.allNouns.contains(node)) {<br>                        this.allNouns.ceiling(node).addId(Integer.parseInt(parts[0]));<br>                    }else {<br>                        node.addId(Integer.parseInt(parts[0]));<br>                        this.allNouns.add(node);<br>                    }<br>                }<br>                this.synsets.add(strings);</node></p>
<pre><code>            count++;
        }
        in.close();

        this.digraph = new Digraph(count);

        BufferedReader hypernymsReader = new BufferedReader(new FileReader(hypernyms));
        while ((line = hypernymsReader.readLine()) != null){
            String[] temp = line.split(&quot;,&quot;);
            int id = Integer.parseInt(temp[0]);
            for (int i = 1; i &lt; temp.length; i++) {
                this.digraph.addEdge(id, Integer.parseInt(temp[i]));
            }
        }
        hypernymsReader.close();
    } catch (IOException e) {
        e.printStackTrace();
    }

    this.wordnetSap = new SAP(this.digraph);

    onStack = new boolean[digraph.V()];
    marked = new boolean[digraph.V()];
    if (hasCycle(this.digraph)) throw new IllegalArgumentException();
    if (this.possibleRoots.size() &gt; 1) throw new IllegalArgumentException();
}

private boolean hasCycle(Digraph digraph) {
    for (int i = 0; i &lt; digraph.V(); i++) {
        if (!this.marked[i]) dfs(digraph, i);
    }
    return hasCycle;
}

private void dfs(Digraph digraph, int v) {

    onStack[v] = true;
    marked[v] = true;

    if (!digraph.adj(v).iterator().hasNext()) {
        if (!this.possibleRoots.contains(v))
            this.possibleRoots.add(v);
    }
    for (int w : digraph.adj(v)) {
        if (this.hasCycle) return;
        else if (!marked[w]) {
            dfs(digraph, w);
        }
        else if (onStack[w]) this.hasCycle = true;
    }
    onStack[v] = false;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">选对了合适的数据结构，完成了构造方法，其实就完成了绝大部分工作，剩下的实现就相对容易了。</div><div class="line"></div><div class="line">返回wordnet中所有的词：</div></pre></td></tr></table></figure>
<p>public Iterable<string> nouns() {<br>        ArrayList<string> nouns = new ArrayList&lt;&gt;();<br>        for (Node node : this.allNouns) {<br>            nouns.add(node.noun);<br>        }<br>        return nouns;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">判断一个词是否在wordnet中：</div></pre></td></tr></table></figure></string></string></p>
<p>public boolean isNoun(String word) {<br>        if (word == null) throw new NullPointerException();<br>        Node node = new Node(word);<br>        return this.allNouns.contains(node);<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">两个词的最短距离：用SET和Node迅速找到词所对应的可能位置，用sap中的方法可以马上计算。</div></pre></td></tr></table></figure></p>
<p>public int distance(String nounA, String nounB) {<br>        if (nounA == null || nounB == null)<br>            throw new NullPointerException();<br>        if (!isNoun(nounA) || !isNoun(nounB))<br>            throw new IllegalArgumentException();<br>        ArrayList<integer> idAs;<br>        ArrayList<integer> idBs;</integer></integer></p>
<pre><code>    Node nodeA = new Node(nounA);
    Node nodeB = new Node(nounB);
    nodeA = this.allNouns.ceiling(nodeA);
    nodeB = this.allNouns.ceiling(nodeB);
    idAs = nodeA.getIds();
    idBs = nodeB.getIds();

    return wordnetSap.length(idAs, idBs);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">两个词最短路径上的共同上位词的同义词集合：同样用sap中的方法找到位置，然后从事先存好的arraylist中获取同义词集合，拼接成给定的形式。</div></pre></td></tr></table></figure>
<p>public String sap(String nounA, String nounB) {<br>        if (nounA == null || nounB == null)<br>            throw new NullPointerException();<br>        if (!isNoun(nounA) || !isNoun(nounB))<br>            throw new IllegalArgumentException();</p>
<pre><code>    ArrayList&lt;Integer&gt; idAs;
    ArrayList&lt;Integer&gt; idBs;

    Node nodeA = new Node(nounA);
    Node nodeB = new Node(nounB);
    nodeA = this.allNouns.ceiling(nodeA);
    nodeB = this.allNouns.ceiling(nodeB);
    idAs = nodeA.getIds();
    idBs = nodeB.getIds();

    int id = wordnetSap.ancestor(idAs, idBs);
    String[] strings = this.synsets.get(id);
    String result = &quot;&quot;;
    for (int i = 0; i&lt; strings.length; i++) {
        result += strings[i];
        if (i != strings.length - 1)
            result += &quot; &quot;;
    }
    return result;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## Outcast.java</div><div class="line"></div><div class="line">outcast就简单了，从给定的词组中，计算每个词与其他词的最短距离之和。和最大的词自然就是与别的词最不同的了。</div></pre></td></tr></table></figure>
<p>public class Outcast {<br>    private WordNet wordNet;</p>
<pre><code>public Outcast(WordNet wordnet) {
    this.wordNet = wordnet;
}

public String outcast(String[] nouns) {
    int[] distances = new int[nouns.length];
    for (int i = 0; i &lt; nouns.length; i++) {
        String noun = nouns[i];
        for (int j = 0; j &lt; nouns.length; j++) {
            if (i != j) {
                distances[i] += wordNet.distance(noun, nouns[j]);
            }
        }
    }
    int max = 0;
    int id = 0;
    for (int i = 0; i &lt; distances.length; i++) {
        if (distances[i] &gt; max) {
            max = distances[i];
            id = i;
        }
    }

    return nouns[id];
}
</code></pre><p>}<br>```</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>笔者水平有限，上述答案其实只有91分，运行时间不达标。抛砖引玉，希望大神们能够提出改进方法，大家一起学习进步，谢谢！</p>
<p>项目源码在GitHub中，请点<a href="https://github.com/michael0905/WordNet" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/27/wordnet/" data-id="cj0t97vls00052di336y9lu0n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/03/27/seamcarving/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          SeamCarving
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android开发/">Android开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS开发/">iOS开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/28/CoreBluetooth连接蓝牙健康设备/">CoreBluetooth连接蓝牙健康设备</a>
          </li>
        
          <li>
            <a href="/2017/03/28/AFNetworking 3.x 使用心得/">WordNet</a>
          </li>
        
          <li>
            <a href="/2017/03/28/Android蓝牙健康设备开发：Health Device Profile(HDP)/">Android蓝牙健康设备开发：Health Device Profile(HDP)</a>
          </li>
        
          <li>
            <a href="/2017/03/27/seamcarving/">SeamCarving</a>
          </li>
        
          <li>
            <a href="/2017/03/27/wordnet/">WordNet</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Yiyuan Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>