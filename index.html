<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Yiyuan Liu&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Yiyuan Liu's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Yiyuan Liu's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yiyuan Liu's Blog">
  
    <link rel="alternate" href="/atom.xml" title="Yiyuan Liu&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Yiyuan Liu&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-seamcarving" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/27/seamcarving/" class="article-date">
  <time datetime="2017-03-27T03:25:17.000Z" itemprop="datePublished">2017-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Exercise/">Exercise</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/27/seamcarving/">SeamCarving</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>第二周主要内容仍然是关于图的算法，主要内容为：</p>
<ul>
<li><p>最小生成树</p>
<ol>
<li><a href="http://algs4.cs.princeton.edu/43mst/KruskalMST.java.html" target="_blank" rel="external">Kruskal算法</a></li>
</ol>
<ul>
<li><a href="http://algs4.cs.princeton.edu/43mst/LazyPrimMST.java.html" target="_blank" rel="external">延时Prim算法</a></li>
<li><a href="http://algs4.cs.princeton.edu/43mst/PrimMST.java.html" target="_blank" rel="external">即时Prim算法</a></li>
</ul>
</li>
<li><p>最短路径</p>
<ol>
<li><a href="http://algs4.cs.princeton.edu/44sp/DijkstraSP.java.html" target="_blank" rel="external">Dijkstra算法</a>：适用无负权值边的图</li>
<li><a href="http://algs4.cs.princeton.edu/44sp/AcyclicSP.java.html" target="_blank" rel="external">DAG最短路径算法</a>：使用拓扑排序</li>
<li><a href="http://algs4.cs.princeton.edu/44sp/BellmanFordSP.java.html" target="_blank" rel="external">Bellman-Ford算法</a>：适用含负权值边的图</li>
</ol>
</li>
</ul>
<p>编程作业是SeamCarver：<a href="http://coursera.cs.princeton.edu/algs4/assignments/seamCarving.html" target="_blank" rel="external">原题地址</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>SeamCarving是一种调整图像尺寸的算法：从一幅图像中选出最不重要的像素并删去，在尽可能保留图像内容的情况下改变图像的尺寸。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1972331-660935e20fc9cffb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="original image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1972331-af427579a68a1020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="resized image"></p>
<p>上图就是SeamCarving算法的应用，原图尺寸为505-by-287，变换后的图片尺寸为355-by-287。虽然尺寸变了，但是没有发生拉伸扭曲，保留了原图的特征。</p>
<p>算法步骤：</p>
<ol>
<li>计算每个像素点的权重</li>
<li>找到水平（垂直）方向上的权重最小的像素序列，称为seam</li>
<li>移除seam</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1972331-fc4cdeee99bc9727.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vertical seam"></p>
<p>备注：</p>
<ul>
<li>像素点的权重计算使用<code>dual-gradient energy function</code>,具体计算方法在原题中有。</li>
<li>从像素点<code>(i,j)</code>出发(假设垂直方向)只能连接到下一行的相邻三个像素<code>(i-1,j+1)</code>,<code>(i,j+1)</code>,<code>(i+1,j+1)</code></li>
<li>坐标系与默认的不同：<code>(i,j)</code>表示第<code>j</code>行，第<code>i</code>列<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a 3-by-4 image</div><div class="line">  (0, 0)  	  (1, 0)  	  (2, 0)  </div><div class="line">  (0, 1)  	  (1, 1)  	  (2, 1)  </div><div class="line">  (0, 2)  	  (1, 2)  	  (2, 2)  </div><div class="line">  (0, 3)  	  (1, 3)  	  (2, 3)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>API:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class SeamCarver &#123;</div><div class="line">   public SeamCarver(Picture picture)                // create a seam carver object based on the given picture</div><div class="line">   public Picture picture()                          // current picture</div><div class="line">   public     int width()                            // width of current picture</div><div class="line">   public     int height()                           // height of current picture</div><div class="line">   public  double energy(int x, int y)               // energy of pixel at column x and row y</div><div class="line">   public   int[] findHorizontalSeam()               // sequence of indices for horizontal seam</div><div class="line">   public   int[] findVerticalSeam()                 // sequence of indices for vertical seam</div><div class="line">   public    void removeHorizontalSeam(int[] seam)   // remove horizontal seam from current picture</div><div class="line">   public    void removeVerticalSeam(int[] seam)     // remove vertical seam from current picture</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul>
<li>图像的表示使用alg4.jar中的Picture类。但是构造这个类的开销很大，在内部用一个二维数组作为类成员变量来表示图像中每个点，数组中存的值为此像素点<code>int</code>类型的rbg值。在实现算法的时候使用此二维数组，只在<code>public Picture picture()</code>方法中生成Picture对象并返回。</li>
<li><p>核心算法是找到某一方向上的seam，下面一步步思考：</p>
<ol>
<li>首先可以把图像抽象成一个有向图，顶点是每一个像素点，每个顶点有三条边指向下一行（列）的相邻顶点。</li>
<li>seam即是一条最短路径，权值就是最短路径上所有像素点的权重。</li>
<li>这是一个无环有向图（DAG），从时间复杂度考虑应该使用<strong>无环有向图的最短路径算法</strong>，而不是Dijkstra算法。</li>
<li>因此需要得到拓扑顺序，在这里不需要使用深度优先搜索来计算。<strong>以垂直方向为例，自上而下，每一行的拓扑顺序先于下一行，而每一行中各个顶点的顺序无关紧要</strong>。</li>
<li>因此在最短路径算法中，可以直接for循环自上而下遍历所有顶点，进行松弛（relax）操作。</li>
</ol>
</li>
<li><p>水平和垂直方向：两个不同方向的算法实质是一样的，只要先对表示图像的二维数组进行转置，就能够复用代码。<br>java中二维数组实际是由一维数组的每个元素表示其他各个一维数组，根据题意，垂直方向的像素作为第二层数组，方便用<code>System.arraycopy()</code>来整体移动，因此我们实现<code>removeHorizontalSeam(int[] seam)</code>方法：即水平方向上每行移除一个像素点，再整体移动剩余像素点；而对于<code>removeVerticalSeam(int[] seam)</code>方法，只要转置二维数组、调用<code>removeHorizontalSeam(int[] seam)</code>、再转置二维数组。</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private int[][] colors;</div></pre></td></tr></table></figure></p>
<p>构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public Picture picture() &#123;</div><div class="line">        Picture picture = new Picture(colors.length, colors[0].length);</div><div class="line">        for (int i = 0; i &lt; colors.length; i++) &#123;</div><div class="line">            for (int j = 0; j &lt; colors[0].length; j++) &#123;</div><div class="line">                Color color = new Color(this.colors[i][j]);</div><div class="line">                picture.set(i, j, color);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return picture;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>width()</code>和<code>height()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public int width() &#123;</div><div class="line">    return this.colors.length;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public int height() &#123;</div><div class="line">    return this.colors[0].length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>energy()</code>：使用<code>dual-gradient energy function</code>来计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public double energy(int x, int y) &#123;</div><div class="line">        if (x &lt; 0 || x &gt; this.width() - 1 || y &lt; 0 || y &gt; this.height() - 1) &#123;</div><div class="line">            throw new IndexOutOfBoundsException();</div><div class="line">        &#125;</div><div class="line">        if (x == 0 || x == this.width() - 1 || y == 0 || y == this.height() - 1) &#123;</div><div class="line">            return 1000.0;</div><div class="line">        &#125; else &#123;</div><div class="line">            int deltaXRed = red(colors[x - 1][y]) -</div><div class="line">                    red(colors[x + 1][y]);</div><div class="line">            int deltaXGreen = green(colors[x - 1][y]) -</div><div class="line">                    green(colors[x + 1][y]);</div><div class="line">            int deltaXBlue = blue(colors[x - 1][y]) -</div><div class="line">                    blue(colors[x + 1][y]);</div><div class="line"></div><div class="line">            int deltaYRed = red(colors[x][y - 1]) - red(colors[x][y + 1]);</div><div class="line">            int deltaYGreen = green(colors[x][y - 1]) - green(colors[x][y + 1]);</div><div class="line">            int deltaYBlue = blue(colors[x][y - 1]) - blue(colors[x][y + 1]);</div><div class="line"></div><div class="line">            return Math.sqrt(Math.pow(deltaXRed, 2) + Math.pow(deltaXBlue, 2) + Math.pow(deltaXGreen, 2) + Math.pow(deltaYRed, 2) + Math.pow(deltaYBlue, 2) + Math.pow(deltaYGreen, 2));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>findVerticalSeam()</code></p>
<ol>
<li>先计算所有顶点的distTo值，即从第一行到此顶点的最短路径上所有顶点权值之和</li>
<li>找出最后一行中distTo值最小的顶点，此顶点属于seam</li>
<li>根据nodeTo，逐行逆向找到每个属于seam的顶点</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public int[] findVerticalSeam() &#123;</div><div class="line">        int n = this.width() * this.height();</div><div class="line">        int[] seam = new int[this.height()];</div><div class="line">        int[] nodeTo = new int[n];</div><div class="line">        double[] distTo = new double[n];</div><div class="line">        for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">            if (i &lt; width())</div><div class="line">                distTo[i] = 0;</div><div class="line">            else</div><div class="line">                distTo[i] = Double.POSITIVE_INFINITY;</div><div class="line">        &#125;</div><div class="line">        for (int i = 0; i &lt; height(); i++) &#123;</div><div class="line">            for (int j = 0; j &lt; width(); j++) &#123;</div><div class="line">                for (int k = -1; k &lt;= 1; k++) &#123;</div><div class="line">                    if (j + k &lt; 0 || j + k &gt; this.width() - 1 || i + 1 &lt; 0 || i + 1 &gt; this.height() - 1) &#123;</div><div class="line">                        continue;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        if (distTo[index(j + k, i + 1)] &gt; distTo[index(j, i)] + energy(j, i)) &#123;</div><div class="line">                            distTo[index(j + k, i + 1)] = distTo[index(j, i)] + energy(j, i);</div><div class="line">                            nodeTo[index(j + k, i + 1)] = index(j, i);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // find min dist in the last row</div><div class="line">        double min = Double.POSITIVE_INFINITY;</div><div class="line">        int index = -1;</div><div class="line">        for (int j = 0; j &lt; width(); j++) &#123;</div><div class="line">            if (distTo[j + width() * (height() - 1)] &lt; min) &#123;</div><div class="line">                index = j + width() * (height() - 1);</div><div class="line">                min = distTo[j + width() * (height() - 1)];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // find seam one by one</div><div class="line">        for (int j = 0; j &lt; height(); j++) &#123;</div><div class="line">            int y = height() - j - 1;</div><div class="line">            int x = index - y * width();</div><div class="line">            seam[height() - 1 - j] = x;</div><div class="line">            index = nodeTo[index];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return seam;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private int index(int x, int y) &#123;</div><div class="line">        return width() * y + x;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>findHorizontalSeam()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public int[] findHorizontalSeam() &#123;</div><div class="line">        this.colors = transpose(this.colors);</div><div class="line">        int[] seam = findVerticalSeam();</div><div class="line">        this.colors = transpose(this.colors);</div><div class="line">        return seam;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>removeHorizontalSeam</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public void removeHorizontalSeam(int[] seam) &#123;</div><div class="line">        if (height() &lt;= 1) throw new IllegalArgumentException();</div><div class="line">        if (seam == null) throw new NullPointerException();</div><div class="line">        if (seam.length != width()) throw new IllegalArgumentException();</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; seam.length; i++) &#123;</div><div class="line">            if (seam[i] &lt; 0 || seam[i] &gt; height() - 1)</div><div class="line">                throw new IllegalArgumentException();</div><div class="line">            if (i &lt; width() - 1 &amp;&amp; Math.pow(seam[i] - seam[i + 1], 2) &gt; 1)</div><div class="line">                throw new IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int[][] updatedColor = new int[width()][height() - 1];</div><div class="line">        for (int i = 0; i &lt; seam.length; i++) &#123;</div><div class="line">            if (seam[i] == 0) &#123;</div><div class="line">                System.arraycopy(this.colors[i], seam[i] + 1, updatedColor[i], 0, height() - 1);</div><div class="line">            &#125; else if (seam[i] == height() - 1) &#123;</div><div class="line">                System.arraycopy(this.colors[i], 0, updatedColor[i], 0, height() - 1);</div><div class="line">            &#125; else &#123;</div><div class="line">                System.arraycopy(this.colors[i], 0, updatedColor[i], 0, seam[i]);</div><div class="line">                System.arraycopy(this.colors[i], seam[i] + 1, updatedColor[i], seam[i], height() - seam[i] - 1);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        this.colors = updatedColor;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>removeVerticalSeam:转置后复用removeHorizontalSeam(int[] seam)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void removeVerticalSeam(int[] seam) &#123;</div><div class="line">        this.colors = transpose(this.colors);</div><div class="line">        removeHorizontalSeam(seam);</div><div class="line">        this.colors = transpose(this.colors);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最后是转置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private int[][] transpose(int[][] origin) &#123;</div><div class="line">        if (origin == null) throw new NullPointerException();</div><div class="line">        if (origin.length &lt; 1) throw new IllegalArgumentException();</div><div class="line">        int[][] result = new int[origin[0].length][origin.length];</div><div class="line">        for (int i = 0; i &lt; origin[0].length; i++) &#123;</div><div class="line">            for (int j = 0; j &lt; origin.length; j++) &#123;</div><div class="line">                result[i][j] = origin[j][i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="成绩"><a href="#成绩" class="headerlink" title="成绩"></a>成绩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ASSESSMENT SUMMARY</div><div class="line"></div><div class="line">Compilation:  PASSED</div><div class="line">API:          PASSED</div><div class="line"></div><div class="line">Findbugs:     PASSED</div><div class="line">Checkstyle:   FAILED (3 warnings)</div><div class="line"></div><div class="line">Correctness:  31/31 tests passed</div><div class="line">Memory:       7/7 tests passed</div><div class="line">Timing:       6/6 tests passed</div><div class="line"></div><div class="line">Aggregate score: 100.00%</div><div class="line">[Compilation: 5%, API: 5%, Findbugs: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]</div></pre></td></tr></table></figure>
<p>完整代码和测试用例在GitHub上，欢迎讨论<br><code>https://github.com/michael0905/SeamCarver</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/27/seamcarving/" data-id="cj0rk6sdr0001gji35vv9lyl1" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-wordnet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/27/wordnet/" class="article-date">
  <time datetime="2017-03-27T03:25:16.000Z" itemprop="datePublished">2017-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Exercise/">Exercise</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/27/wordnet/">WordNet</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在coursera上学习Princeton大学的Algorithm PartII，这个系列的两门课是我见过最好的算法课。主讲Robert Sedgewick师承高德纳，声名远播，虽然年纪大了，但是讲课思路清晰，深入浅出。与Kevin Wayne共同编著的《算法》第四版作为教材，没有《算法导论》那么偏理论、晦涩难懂，能够把常见的数据结构和算法讲得很透彻，容易理解。<br>更值得称道的是这门课编程作业及其评分系统。上课的内容是基础的数据结构和算法，但编程作业往往是这些算法的实际应用，能真正理解为什么在给定的情况下要使用这样的数据结构、算法。作业的评分不仅仅是看正确与否，还有运行时间、内存的要求，会给出详细的分析报告，如果不是ACM大神，这些作业都值得花时间去仔细琢磨。<br>下面进入正题，第一周的作业WordNet</p>
<p>##题目<br>WordNet is a semantic lexicon for theEnglish language that is used extensively by computational linguistsand cognitive scientists; for example, it was a key component in IBM’sWatson.WordNet groups words into sets of synonyms called synsets and describes semantic relationships between them.One such relationship is the is-a relationship, which connects a hyponym(more specific synset) to a hypernym (more general synset).For example, locomotion is a hypernym of runningand running is a hypernym of dash.</p>
<p>The WordNet digraph.Your first task is to build the wordnet digraph: each vertex v is an integer that represents a synset, and each directed edge v→w represents that w is a hypernym of v.The wordnet digraph is a rooted DAG: it is acylic and has one vertex thatis an ancestor of every other vertex.However, it is not necessarily a tree because a synset can have more than onehypernym. A small subgraph of the wordnet digraph is illustrated below.</p>
<p>The WordNet input file formats.We now describe the two data files that you will use to create the wordnet digraph.The files are in CSV format: each line contains a sequence of fields,separated by commas.</p>
<p>List of noun synsets.The file synsets.txtlists all the (noun) synsets in WordNet.The first field is the synset id (an integer),the second field is the synonym set (or synset), and thethird field is its dictionary definition (or gloss).For example, the line<br>36,AND_circuit AND_gate,a circuit in a computer that fires only when all of its inputs fire<br>means that the synset { AND_circuit, AND_gate }has an id number of 36 and it’s gloss isa circuit in a computer that fires only when all of its inputs fire.The individual nouns that comprise a synset are separatedby spaces (and a synset element is not permitted to contain a space).The S synset ids are numbered 0 through S − 1;the id numbers will appear consecutively in the synset file.<br>List of hypernyms.The file hypernyms.txtcontains the hypernym relationships:The first field is a synset id; subsequent fields are the id numbersof the synset’s hypernyms. For example, the following line<br>164,21012,56099<br>means that the the synset 164 (“Actifed”) has two hypernyms:21012 (“antihistamine”) and56099 (“nasal_decongestant”),representing that Actifed is both an antihistamine and a nasal decongestant.The synsets are obtained from the corresponding lines in the file synsets.txt.</p>
<p>164,Actifed,trade name for a drug containing an antihistamine and a decongestant…<br>21012,antihistamine,a medicine used to treat allergies…<br>56099,nasal_decongestant,a decongestant that provides temporary relief of nasal…<br>WordNet data type.Implement an immutable data type WordNet with the following API:</p>
<p>// constructor takes the name of the two input files<br>public WordNet(String synsets, String hypernyms)</p>
<p>// the set of nouns (no duplicates), returned as an Iterable<br>public Iterable<string> nouns()</string></p>
<p>// is the word a WordNet noun?<br>public boolean isNoun(String word)</p>
<p>// distance between nounA and nounB (defined below)<br>public int distance(String nounA, String nounB)</p>
<p>// a synset (second field of synsets.txt) that is the common ancestor of nounA and nounB<br>// in a shortest ancestral path (defined below)<br>public String sap(String nounA, String nounB)</p>
<p>// for unit testing of this class<br>public static void main(String[] args)<br>The constructor should throw a java.lang.IllegalArgumentExceptionif the input does not correspond to a rooted DAG.The distance() and sap() methodsshould throw a java.lang.IllegalArgumentExceptionunless both of the noun arguments are WordNet nouns.<br>Your data type should use space linear in the input size(size of synsets and hypernyms files).The constructor should take time linearithmic (or better) in the input size.The method isNoun() should run in time logarithmic (or better) inthe number of nouns.The methods distance() and sap() should run in time linear in thesize of the WordNet digraph.</p>
<p>Shortest ancestral path.An ancestral path between two verticesv and w in a digraph is a directed path fromv to a common ancestor x, together witha directed path from w to the same ancestor x. A shortest ancestral path is an ancestral path of minimum total length.For example, in the digraph at left(digraph1.txt),the shortest ancestral path between3 and 11 has length 4 (with common ancestor 1).In the digraph at right (digraph2.txt),one ancestral path between 1 and 5 has length 4(with common ancestor 5), but the shortest ancestral path has length 2(with common ancestor 0).</p>
<p>SAP data type.Implement an immutable data type SAP with the following API:</p>
<p>// constructor takes a digraph (not necessarily a DAG)<br>public SAP(Digraph G)</p>
<p>// length of shortest ancestral path between v and w; -1 if no such path<br>public int length(int v, int w)</p>
<p>// a common ancestor of v and w that participates in a shortest ancestral path; -1 if no such path<br>public int ancestor(int v, int w)</p>
<p>// length of shortest ancestral path between any vertex in v and any vertex in w; -1 if no such path<br>public int length(Iterable<integer> v, Iterable<integer> w)</integer></integer></p>
<p>// a common ancestor that participates in shortest ancestral path; -1 if no such path<br>public int ancestor(Iterable<integer> v, Iterable<integer> w)</integer></integer></p>
<p>// for unit testing of this class (such as the one below)<br>public static void main(String[] args)<br>All methods should throw a java.lang.IndexOutOfBoundsException if one (or more) of the input arguments is not between 0 and G.V() - 1.You may assume that the iterable arguments contain at least one integer.All methods (and the constructor) should take time at mostproportional to E + Vin the worst case, where E and V are the number of edges and verticesin the digraph, respectively.Your data type should use space proportional to E + V.<br>Test client.The following test client takes the name of a digraph input file asas a command-line argument, constructs the digraph,reads in vertex pairs from standard input,and prints out the length of the shortest ancestral path between the two verticesand a common ancestor that participates in that path:</p>
<p>public static void main(String[] args) {<br>    In in = new In(args[0]);<br>    Digraph G = new Digraph(in);<br>    SAP sap = new SAP(G);<br>    while (!StdIn.isEmpty()) {<br>        int v = StdIn.readInt();<br>        int w = StdIn.readInt();<br>        int length   = sap.length(v, w);<br>        int ancestor = sap.ancestor(v, w);<br>        StdOut.printf(“length = %d, ancestor = %d\n”, length, ancestor);<br>    }<br>}<br>Here is a sample execution:<br>% more digraph1.txt             % java SAP digraph1.txt<br>13                              3 11<br>11                              length = 4, ancestor = 1<br> 7  3<br> 8  3                           9 12<br> 3  1                           length = 3, ancestor = 5<br> 4  1<br> 5  1                           7 2<br> 9  5                           length = 4, ancestor = 0<br>10  5<br>11 10                           1 6<br>12 10                           length = -1, ancestor = -1<br> 1  0<br> 2  0<br>Measuring the semantic relatedness of two nouns.Semantic relatedness refers to the degree to which two concepts are related. Measuring semantic relatedness is a challenging problem. For example, most of us agree that George Bush and John Kennedy (two U.S. presidents)are more related than are George Bushand chimpanzee (two primates). However, not most of us agree that George Bush and Eric Arthur Blair are related concepts. But if one is aware that George Bush and Eric Arthur Blair (aka George Orwell) are both communicators, then it becomes clear that the two concepts might be related.</p>
<p>We define the semantic relatednessof two wordnet nouns A and B as follows:</p>
<p>distance(A, B) = distance is the minimum length of any ancestral path betweenany synset v of A and any synset w of B.<br>This is the notion of distance that you will use to implement thedistance() and sap() methods in the WordNet data type.</p>
<p>Outcast detection.Given a list of wordnet nouns A1, A2,…, An, which nounis the least related to the others? To identify an outcast,compute the sum of the distances between each noun and every other one:</p>
<p>di   =  dist(Ai, A1)   +  dist(Ai, A2)   +   …   +   dist(Ai, An)<br>and return a noun Atfor which dt is maximum.<br>Implement an immutable data type Outcast with the following API:</p>
<p>// constructor takes a WordNet object<br>public Outcast(WordNet wordnet)</p>
<p>// given an array of WordNet nouns, return an outcast<br>public String outcast(String[] nouns)</p>
<p>// for unit testing of this class (such as the one below)<br>public static void main(String[] args)<br>Assume that argument array to the outcast() methodcontains only valid wordnet nouns (and that it contains at least two such nouns).<br>The following test client takes from the command line the name of a synset file, the name of a hypernym file, followed by thenames of outcast files, and prints out an outcast in each file:</p>
<p>public static void main(String[] args) {<br>    WordNet wordnet = new WordNet(args[0], args[1]);<br>    Outcast outcast = new Outcast(wordnet);<br>    for (int t = 2; t &lt; args.length; t++) {<br>        In in = new In(args[t]);<br>        String[] nouns = in.readAllStrings();<br>        StdOut.println(args[t] + “: “ + outcast.outcast(nouns));<br>    }<br>}<br>Here is a sample execution:<br>% more outcast5.txt<br>horse zebra cat bear table</p>
<p>% more outcast8.txt<br>water soda bed orange_juice milk apple_juice tea coffee</p>
<p>% more outcast11.txt<br>apple pear peach banana lime lemon blueberry strawberry mango watermelon potato</p>
<p>% java Outcast synsets.txt hypernyms.txt outcast5.txt outcast8.txt outcast11.txt<br>outcast5.txt: table<br>outcast8.txt: bed<br>outcast11.txt: potato</p>
<p>##题目分析<br>wordnet是一个有上下位关系的英语词典，可以描述词语间的关系。下位词是上位词的一种具体描述，是一种isa关系。例如running是dash的上位词。从数据结构上来看wordnet是一个有向无环图。每个节点是一个同义词集合（synset），一个英语单词或复合词可能有多个意思，因此可能会出现在多个不同节点中。每条边都是由下位词指向上位词，有且仅有从下位词到上位词的路径，因此不可能存在环。<br>题目中wordnet是以synsets.txt和hypernyms.txt的形式给出。synsets.txt中按字母顺序给出了所有同义词集合的序号、集合、描述。hypernyms.txt按同义词集合的序号给出了上下位的关系，每行第一个序号是下位词，之后的序号都是上位词。一个下位词可能存在多个上位词。<br>题目的要求是实现三个类：</p>
<ul>
<li>WordNet.java</li>
<li>SAP.java</li>
<li>Outcast.java</li>
</ul>
<p>SAP.java是一个基础类，给定一个有向图，计算两点之间的最短距离，以及两点的共同祖先。首先应该完成这个类。<br>WordNet.java中实现计算wordnet结构中两个词的最短距离及共同祖先。<br>Outcast.java就比较简单了，找出一组词中最不相关的一个，调用WordNet.java很容易实现。</p>
<p>##SAP.java<br>下面具体分析每个类的实现<br>首先实现SAP.java，在这个类中实现计算最短距离和共同祖先的算法，然后可以应用到wordnet中。</p>
<p>###分析<br>求最短路径和共同祖先的思想就是从两个不同节点出发，找到都能到达且距离最短的节点。要计算距离，使用广度优先搜索，并且保存和更新每个节点的到出发点的距离。</p>
<p>成员变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private Digraph digraph;</div><div class="line"></div><div class="line">private int ancestor;</div><div class="line">    </div><div class="line">private int length;</div></pre></td></tr></table></figure>
<p>构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public SAP(Digraph G) &#123;</div><div class="line">       if (G == null) throw new NullPointerException();</div><div class="line">       this.digraph = G;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>由于最短距离是两个节点到某公共节点的距离组合，可能出现多种情况，因此自定义一个数据结构Node来表示公共节点，把所有可能的公共节点放入一个优先队列中，最后从中取最小值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private class Node implements Comparable&lt;Node&gt; &#123;</div><div class="line">        private int length;</div><div class="line">        private int id;</div><div class="line"></div><div class="line">        Node(int length, int id) &#123;</div><div class="line">            this.length = length;</div><div class="line">            this.id = id;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public int compareTo(Node o) &#123;</div><div class="line">            if (length &gt; o.length) &#123;</div><div class="line">                return 1;</div><div class="line">            &#125; else if (length == o.length) &#123;</div><div class="line">                return 0;</div><div class="line">            &#125; else &#123;</div><div class="line">                return -1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">```   </div><div class="line">求最短距离的完整代码：</div><div class="line"></div><div class="line">1. 先对一个节点进行广度优先搜素，计算到所有节点的距离。</div><div class="line">2. 对另一个节点进行广度优先搜素，计算到所有节点的距离，如果某节点可以从两个节点分别到达，则存在优先队列中。</div><div class="line">3. 从优先队列中取出最小值，即为最短距离。</div></pre></td></tr></table></figure>
<p>// length of shortest ancestral path between v and w; -1 if no such path<br>    public int length(int v, int w) {<br>        if (v &lt; 0 || v &gt;= digraph.V() || w &lt; 0 || w &gt;= digraph.V())<br>            throw new IndexOutOfBoundsException();<br>        MinPQ<node> possibleLength = new MinPQ();<br>        boolean[] marked = new boolean[this.digraph.V()];<br>        marked[v] = true;<br>        int[] pathV = new int[digraph.V()];<br>        int[] pathW = new int[digraph.V()];<br>        for (int i = 0; i &lt; digraph.V(); i++) {<br>            pathV[i] = -1;<br>            pathW[i] = -1;<br>        }<br>        pathV[v] = 0;<br>        pathW[w] = 0;</node></p>
<pre><code>    // bfs on v
    Queue&lt;Integer&gt; queue = new Queue&lt;&gt;();
    queue.enqueue(v);
    while (!queue.isEmpty()) {
        int vertex = queue.dequeue();
        for (int nextVertex : digraph.adj(vertex)) {
            if (!marked[nextVertex]) {
                marked[nextVertex] = true;
                queue.enqueue(nextVertex);
                if (pathV[nextVertex] == -1 || pathV[nextVertex] &gt; pathV[vertex] + 1) {
                    pathV[nextVertex] = pathV[vertex] + 1;
                }

            }
        }
    }

    // bfs on w
    marked = new boolean[this.digraph.V()];
    marked[w] = true;
    queue.enqueue(w);
    while (!queue.isEmpty()) {
        int vertex = queue.dequeue();
        if (pathV[vertex] &gt; -1) {
            Node node = new Node(pathV[vertex] + pathW[vertex], vertex);
            possibleLength.insert(node);
        }
        for (int nextVertex : digraph.adj(vertex)) {
            if (!marked[nextVertex]) {
                marked[nextVertex] = true;
                queue.enqueue(nextVertex);
                if (pathW[nextVertex] == -1 || pathW[nextVertex] &gt; pathW[vertex] + 1) {
                    pathW[nextVertex] = pathW[vertex] + 1;
                }

            }
        }
    }
    if (possibleLength.size() &gt; 0) {
        Node node = possibleLength.delMin();
        this.length = node.length;
        this.ancestor = node.id;
    } else {
        this.length = -1;
        this.ancestor = -1;
    }
    return this.length;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">共同祖先在计算最短距离时也能获得，Node中的id就是共同祖先，因此可以复用。</div></pre></td></tr></table></figure>
<p>// a common ancestor of v and w that participates in a shortest ancestral path; -1 if no such path<br>    public int ancestor(int v, int w) {<br>        length(v, w);<br>        return this.ancestor;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">输入的v,w为多个节点时，直接用暴力for循环找出每两个节点间的最短距离和共同祖先，存到优先队列中，最后取出的就是两组节点间的最短纪录和共同祖先。</div><div class="line">代码：</div></pre></td></tr></table></figure></p>
<pre><code>// length of shortest ancestral path between any vertex in v and any vertex in w; -1 if no such path
public int length(Iterable&lt;Integer&gt; v, Iterable&lt;Integer&gt; w) {
    if (v == null || w == null) throw new NullPointerException();
    MinPQ&lt;Node&gt; possibleNodes = new MinPQ();
    for (int nodeV : v) {
        if (nodeV &lt; 0 || nodeV &gt; this.digraph.V())
            throw new IndexOutOfBoundsException();
        for (int nodeW : w) {
            if (nodeW &lt; 0 || nodeW &gt; this.digraph.V())
                throw new IndexOutOfBoundsException();

            Node node = new Node(length(nodeV, nodeW), ancestor(nodeV, nodeW));
            possibleNodes.insert(node);
        }
    }

    if (possibleNodes.size() &gt; 0) {
        Node node = possibleNodes.delMin();
        this.length = node.length;
        this.ancestor = node.id;
    } else {
        this.length = -1;
        this.ancestor = -1;
    }
    return this.length;
}

// a common ancestor that participates in shortest ancestral path; -1 if no such path
public int ancestor(Iterable&lt;Integer&gt; v, Iterable&lt;Integer&gt; w) {
    length(v, w);
    return this.ancestor;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## WordNet.java</div><div class="line">要把sap中的算法实际高效地应用到wordnet中并不简单，需要找到适合的数据结构来储存我们需要的信息并且能够高效地查询。</div><div class="line"></div><div class="line">题目要求</div><div class="line"></div><div class="line">1. 返回wordnet中所有的词</div><div class="line">2. 判断一个词是否在wordnet中</div><div class="line">3. 两个词的最短距离</div><div class="line">4. 两个词最短路径上的共同上位词的同义词集合</div><div class="line"></div><div class="line"></div><div class="line">要做到1和2两个要求，需要一个没有重复词的集合，而且能够根据词来快速搜索。提到快速搜索，立即想到时间复杂度log(n)的二叉搜索树，正好符合题目的时间要求。因此，使用PartI中讲到过的SET&lt;key&gt;(在Alg4.jar中，用平衡二叉树实现log(n)的插入、搜索)。</div><div class="line"></div><div class="line">SET需要一个key来实现搜索。要求搜索的是词，但不能直接以string作为key，因为还要考虑到最短路径的实现。因此，用一个自定义结构：实现Comparable接口时比较的是词的字母顺序，另外由于词的多义性用一个ArrayList存放出现在wordnet中的可能位置。</div></pre></td></tr></table></figure>
<p>private class Node implements Comparable<node> {<br>        private ArrayList<integer> ids;<br>        private String noun;<br>        Node(String noun) {<br>            this.noun = noun;<br>            this.ids = new ArrayList&lt;&gt;();<br>        }</integer></node></p>
<pre><code>    private void addId(int id) {
        this.ids.add(id);
    }

    private ArrayList&lt;Integer&gt; getIds() {
        return this.ids;
    }

    @Override
    public int compareTo(Node o) {
        return this.noun.compareTo(o.noun);
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">成员变量：</div></pre></td></tr></table></figure>
<p>private SAP wordnetSap;<br>    private Digraph digraph;<br>    private boolean hasCycle;<br>    private boolean[] onStack;<br>    private boolean[] marked;<br>    private ArrayList<integer> possibleRoots; // a DAG has only one root<br>    private ArrayList<string[]> synsets; // synsets for each wordnet node<br>    private SET<node> allNouns; // SET to store Node<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">构造方法：读取synsets.txt和hypernyms.txt,构建表示wordnet的图。Node表示词以及词可能出现的位置，建立SET。与sap中不同，共同祖先需要根据序号返回同义词组，与SET的思路不一致，因此还需要一个ArrayList来表示每个序号对应的同义词组。</div><div class="line"></div><div class="line">根据题目要求，还需要检查构建的wordnet图是否合法，即检查是否无环、是否只有一个root。这个检查合法性同样用广度优先搜索可以完成：</div><div class="line"></div><div class="line">* 是否无环：搜索时如果之前访问过某节点，则构成环。</div><div class="line">* 是否只有一个root：无论从哪个节点开始搜索，最后一个节点（没有指向其他节点的边）是唯一的。</div></pre></td></tr></table></figure></node></string[]></integer></p>
<p>public WordNet(String synsets, String hypernyms) {<br>        if (synsets == null || hypernyms == null)<br>            throw new NullPointerException();<br>        possibleRoots = new ArrayList&lt;&gt;();<br>        this.synsets = new ArrayList&lt;&gt;();<br>        allNouns = new SET<node>();<br>        int count = 0;<br>        try {<br>            BufferedReader in = new BufferedReader(new FileReader(synsets));<br>            String line;<br>            while ((line = in.readLine()) != null) {<br>                String[] parts = line.split(“,”);<br>                String aSynset = parts[1];<br>                String[] strings = aSynset.split(“ “);<br>                for (String str : strings) {<br>                    Node node = new Node(str);<br>                    if (this.allNouns.contains(node)) {<br>                        this.allNouns.ceiling(node).addId(Integer.parseInt(parts[0]));<br>                    }else {<br>                        node.addId(Integer.parseInt(parts[0]));<br>                        this.allNouns.add(node);<br>                    }<br>                }<br>                this.synsets.add(strings);</node></p>
<pre><code>            count++;
        }
        in.close();

        this.digraph = new Digraph(count);

        BufferedReader hypernymsReader = new BufferedReader(new FileReader(hypernyms));
        while ((line = hypernymsReader.readLine()) != null){
            String[] temp = line.split(&quot;,&quot;);
            int id = Integer.parseInt(temp[0]);
            for (int i = 1; i &lt; temp.length; i++) {
                this.digraph.addEdge(id, Integer.parseInt(temp[i]));
            }
        }
        hypernymsReader.close();
    } catch (IOException e) {
        e.printStackTrace();
    }

    this.wordnetSap = new SAP(this.digraph);

    onStack = new boolean[digraph.V()];
    marked = new boolean[digraph.V()];
    if (hasCycle(this.digraph)) throw new IllegalArgumentException();
    if (this.possibleRoots.size() &gt; 1) throw new IllegalArgumentException();
}

private boolean hasCycle(Digraph digraph) {
    for (int i = 0; i &lt; digraph.V(); i++) {
        if (!this.marked[i]) dfs(digraph, i);
    }
    return hasCycle;
}

private void dfs(Digraph digraph, int v) {

    onStack[v] = true;
    marked[v] = true;

    if (!digraph.adj(v).iterator().hasNext()) {
        if (!this.possibleRoots.contains(v))
            this.possibleRoots.add(v);
    }
    for (int w : digraph.adj(v)) {
        if (this.hasCycle) return;
        else if (!marked[w]) {
            dfs(digraph, w);
        }
        else if (onStack[w]) this.hasCycle = true;
    }
    onStack[v] = false;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">选对了合适的数据结构，完成了构造方法，其实就完成了绝大部分工作，剩下的实现就相对容易了。</div><div class="line"></div><div class="line">返回wordnet中所有的词：</div></pre></td></tr></table></figure>
<p>public Iterable<string> nouns() {<br>        ArrayList<string> nouns = new ArrayList&lt;&gt;();<br>        for (Node node : this.allNouns) {<br>            nouns.add(node.noun);<br>        }<br>        return nouns;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">判断一个词是否在wordnet中：</div></pre></td></tr></table></figure></string></string></p>
<p>public boolean isNoun(String word) {<br>        if (word == null) throw new NullPointerException();<br>        Node node = new Node(word);<br>        return this.allNouns.contains(node);<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">两个词的最短距离：用SET和Node迅速找到词所对应的可能位置，用sap中的方法可以马上计算。</div></pre></td></tr></table></figure></p>
<p>public int distance(String nounA, String nounB) {<br>        if (nounA == null || nounB == null)<br>            throw new NullPointerException();<br>        if (!isNoun(nounA) || !isNoun(nounB))<br>            throw new IllegalArgumentException();<br>        ArrayList<integer> idAs;<br>        ArrayList<integer> idBs;</integer></integer></p>
<pre><code>    Node nodeA = new Node(nounA);
    Node nodeB = new Node(nounB);
    nodeA = this.allNouns.ceiling(nodeA);
    nodeB = this.allNouns.ceiling(nodeB);
    idAs = nodeA.getIds();
    idBs = nodeB.getIds();

    return wordnetSap.length(idAs, idBs);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">两个词最短路径上的共同上位词的同义词集合：同样用sap中的方法找到位置，然后从事先存好的arraylist中获取同义词集合，拼接成给定的形式。</div></pre></td></tr></table></figure>
<p>public String sap(String nounA, String nounB) {<br>        if (nounA == null || nounB == null)<br>            throw new NullPointerException();<br>        if (!isNoun(nounA) || !isNoun(nounB))<br>            throw new IllegalArgumentException();</p>
<pre><code>    ArrayList&lt;Integer&gt; idAs;
    ArrayList&lt;Integer&gt; idBs;

    Node nodeA = new Node(nounA);
    Node nodeB = new Node(nounB);
    nodeA = this.allNouns.ceiling(nodeA);
    nodeB = this.allNouns.ceiling(nodeB);
    idAs = nodeA.getIds();
    idBs = nodeB.getIds();

    int id = wordnetSap.ancestor(idAs, idBs);
    String[] strings = this.synsets.get(id);
    String result = &quot;&quot;;
    for (int i = 0; i&lt; strings.length; i++) {
        result += strings[i];
        if (i != strings.length - 1)
            result += &quot; &quot;;
    }
    return result;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## Outcast.java</div><div class="line"></div><div class="line">outcast就简单了，从给定的词组中，计算每个词与其他词的最短距离之和。和最大的词自然就是与别的词最不同的了。</div></pre></td></tr></table></figure>
<p>public class Outcast {<br>    private WordNet wordNet;</p>
<pre><code>public Outcast(WordNet wordnet) {
    this.wordNet = wordnet;
}

public String outcast(String[] nouns) {
    int[] distances = new int[nouns.length];
    for (int i = 0; i &lt; nouns.length; i++) {
        String noun = nouns[i];
        for (int j = 0; j &lt; nouns.length; j++) {
            if (i != j) {
                distances[i] += wordNet.distance(noun, nouns[j]);
            }
        }
    }
    int max = 0;
    int id = 0;
    for (int i = 0; i &lt; distances.length; i++) {
        if (distances[i] &gt; max) {
            max = distances[i];
            id = i;
        }
    }

    return nouns[id];
}
</code></pre><p>}<br>```</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>笔者水平有限，上述答案其实只有91分，运行时间不达标。抛砖引玉，希望大神们能够提出改进方法，大家一起学习进步，谢谢！</p>
<p>项目源码在GitHub中，请点<a href="https://github.com/michael0905/WordNet" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/27/wordnet/" data-id="cj0rk6sdw0002gji39n9iwyn5" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/16/hello-world/" class="article-date">
  <time datetime="2017-03-16T03:21:30.000Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/16/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/16/hello-world/" data-id="cj0rk6sdo0000gji306ryoc6i" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categorieën</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Exercise/">Exercise</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/27/seamcarving/">SeamCarving</a>
          </li>
        
          <li>
            <a href="/2017/03/27/wordnet/">WordNet</a>
          </li>
        
          <li>
            <a href="/2017/03/16/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Yiyuan Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>